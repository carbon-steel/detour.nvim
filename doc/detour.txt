==============================================================================
                                                                        *detour*

                                                                   *detour-into*
Neovim/Vim's floating windows are a great utility to use in plugins and
functions, but they cannot be used manually as splits are. This is because
creating floats is not simple like calling `:split` or `:vsplit`.
`vim.api.nvim_open_win(...)` requires coordinates and dimensions to make
a float which is too tedious to do by hand.

Detour.nvim brings a single new feature to Neovim: detour windows (aka
detours). Detours are floating windows with the ease-of-use of splits.

They dynamically shape themselves to cover as much of a given area as possible.
They can cover:
* the whole screen (`require("detour").Detour()`)
* the current window (`require("detour").DetourCurrentWindow()`)
* the current detour (both of the above functions would work)

Detours will make sure not to overlap each other unless when a detour is
nested within another.

You will find that there are many cases where using a large floating window is
preferable to creating a smaller split window. On top of that, the nesting
behavior of detours allows you to take a long "detour" into other files/locations
without losing your place in your regular windows. Take a detour, look at
other locations, close the detour, and find your original windows as they
were when you left.

detour.Detour()                                                  *detour.Detour*
    Open a new detour window

    * If this is called from a non-detour window, the largest possible detour
    window will be opened that does not overlap with any other detours.
    * If this is called from a detour window, a detour will be opened nested
    within just the current detour.

    There are cases where there is no space for a new detour window and
    this function call will do nothing.

    Returns: ~
        (integer|nil)  returns detour's window id if successfully
                       created, nil otherwise
                       @nodiscard

    Usage: ~
>lua

        --- local window_id = require("detour").Detour()
        --- if not window_id then
        ---     -- New detour could not be made so stop execution
        ---     return
        --- end
        ---
        --- -- New detour window is open and cursor is moved to it.
<


detour.DetourCurrentWindow()                        *detour.DetourCurrentWindow*
    Open a detour popup covering only the current window.

    There are cases where there is no space for a new detour window and
    this function call will do nothing.

    Returns: ~
        (integer|nil)  returns detour's window id if successfully
                       created, nil otherwise
                       @nodiscard

    Usage: ~
>lua

        --- local window_id = require("detour").DetourCurrentWindow()
        --- if not window_id then
        --- 	-- New detour could not be made so stop execution
        --- 	return
        --- end
        ---
        --- -- New detour window is open and cursor is moved to it.
<


==============================================================================
                                                              *detour.algorithm*

                                                              *detour-algorithm*
Detour's windowing algorithm computes the largest rectangle where a
floating window (detour) can be placed without overlapping windows that must
remain visible.

Overview

 Each detour has a list of "reserved" windows that it is allowed to cover.

 When creating or resizing a detour, the algorithm will find the largest
 rectangular area where a floating window can go that covers only reserved
 windows. That rectangle will be the position and dimensions of the detour.

 `Detour()` creates a detour `d` where all windows that are not currently
 reserved by an existing detour are reserved by `d`.

 `DetourCurrentWindow()` creates a detour `d` where only the current window
 is reserved by `d`.

Resizing

 Whenever windows open, close, or get resized, detours will recalculate the
 largest area they can fill and dynamically reshape themselves. This allows
 them to make room for new windows or to expand to take space that has been
 freed up.

==============================================================================
                                                              *detour.movements*

Detour.nvim breaks window navigation commands such as
`<C-w>w`, `<C-w>j`, or `vim.cmd.wincmd("h")`. Instead of
using those, the user MUST use the following window navigation
commands that this plugin provides that implements moving
between windows while skipping over windows covered by detours.

NOTE: Regular window movements such as `<C-w>w`, `<C-w>j`,
`vim.cmd.wincmd("h")` should still work in automated
scripts/functions. Still, you may find it more useful to use detour's
"detour-aware" movement functions in your scripts/functions as well.

                                                              *detour-movements*
movements._safe_state_handler()                  *movements._safe_state_handler*
    DO NOT USE. FOR TESTING ONLY.


movements.DetourWinCmdL()                              *movements.DetourWinCmdL*
     Switch to a window to the right. Skip over any non-floating windows
     covered by a detour.

    Returns: ~
        (nil)

    Usage: ~
>lua

        --- local detour_moves = require("detour.movements")
        --- vim.keymap.set({ "n", "t" }, "<C-l>", detour_moves.DetourWinCmdL)
        --- vim.keymap.set({ "n", "t" }, "<C-w>l", detour_moves.DetourWinCmdL)
        --- vim.keymap.set({ "n", "t" }, "<C-w><C-l>", detour_moves.DetourWinCmdL)
        ---
<


movements.DetourWinCmdH()                              *movements.DetourWinCmdH*
     Switch to a window to the left. Skip over any non-floating windows
     covered by a detour.

    Returns: ~
        (nil)

    Usage: ~
>lua

        --- local detour_moves = require("detour.movements")
        --- vim.keymap.set({ "n", "t" }, "<C-h>", detour_moves.DetourWinCmdH)
        --- vim.keymap.set({ "n", "t" }, "<C-w>h", detour_moves.DetourWinCmdH)
        --- vim.keymap.set({ "n", "t" }, "<C-w><C-h>", detour_moves.DetourWinCmdH)
        ---
<


movements.DetourWinCmdJ()                              *movements.DetourWinCmdJ*
     Switch to a window below. Skip over any non-floating windows
     covered by a detour.

    Returns: ~
        (nil)

    Usage: ~
>lua

        --- local detour_moves = require("detour.movements")
        --- vim.keymap.set({ "n", "t" }, "<C-j>", detour_moves.DetourWinCmdJ)
        --- vim.keymap.set({ "n", "t" }, "<C-w>j", detour_moves.DetourWinCmdJ)
        --- vim.keymap.set({ "n", "t" }, "<C-w><C-j>", detour_moves.DetourWinCmdJ)
        ---
<


movements.DetourWinCmdK()                              *movements.DetourWinCmdK*
     Switch to a window above. Skip over any non-floating windows
     covered by a detour.

    Returns: ~
        (nil)

    Usage: ~
>lua

        --- local detour_moves = require("detour.movements")
        --- vim.keymap.set({ "n", "t" }, "<C-k>", detour_moves.DetourWinCmdK)
        --- vim.keymap.set({ "n", "t" }, "<C-w>k", detour_moves.DetourWinCmdK)
        --- vim.keymap.set({ "n", "t" }, "<C-w><C-k>", detour_moves.DetourWinCmdK)
        ---
<


movements.DetourWinCmdW()                              *movements.DetourWinCmdW*
     Switch windows in a cycle. Skip over any non-floating windows covered
     by a detour.

    Returns: ~
        (nil)

    Usage: ~
>lua

        --- local detour_moves = require("detour.movements")
        --- vim.keymap.set({ "n", "t" }, "<C-w>", detour_moves.DetourWinCmdW)
        --- vim.keymap.set({ "n", "t" }, "<C-w>w", detour_moves.DetourWinCmdW)
        --- vim.keymap.set({ "n", "t" }, "<C-w><C-w>", detour_moves.DetourWinCmdW)
        ---
<


==============================================================================
                                                               *detour.features*

 Optional detour.nvim features.

                                                               *detour-features*
features.ShowPathInTitle({popup_id})                  *features.ShowPathInTitle*
    Show the buffer path in the given popup's title and keep it updated.

    Parameters: ~
        {popup_id}  (integer)

    Returns: ~
        (nil)


features.CloseOnLeave({popup_id})                        *features.CloseOnLeave*
    Close the popup when focus leaves to a non-floating window.

    Parameters: ~
        {popup_id}  (integer)

    Returns: ~
        (nil)


features.UncoverWindow({window})                        *features.UncoverWindow*
    Prevent detours from covering the provided window.

    Parameters: ~
        {window}  (integer)

    Returns: ~
        (boolean)


features.UncoverWindowWithMouse()              *features.UncoverWindowWithMouse*
    Prompt to click a window and mark it as uncovered by detours.

    Returns: ~
        (nil)


features.HideAllDetours()                              *features.HideAllDetours*
    Temporarily hide all detours in current tabpage.

    Returns: ~
        (nil)


features.RevealAllDetours()                          *features.RevealAllDetours*
    Reveal all detours previously hidden in current tabpage.

    Returns: ~
        (nil)


features.CloseCurrentStack()                        *features.CloseCurrentStack*
     Closes current detour along with all detours that it covers and covers it.
     When not inside a detour, this function is a no-op.

    Returns: ~
        (boolean)  true if close operation succeeded and false otherwise
                   @nodiscard


vim:tw=78:ts=8:noet:ft=help:norl:
